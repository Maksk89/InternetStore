<?php
namespace classes;

class BaseModel
{
    // Свойство, отвечающее за имя таблицы, к которой будет подключаться модель.
    public $tableName = '';

    // Метод, добавляющий к key sql кавычки.
    public function envelope($key)
    {
        return '`' . $key . '`';
    }

    // Метод перебирает массив и к каждому элементу добавляет sql кавычки.
    public function addQuotes($array)
    {
        return array_map(array('classes\BaseModel', 'envelope'), $array);
    }

    // Метод select из массивов собирает простую строку запроса sql
    // SELECT [Список полей для вывода]
    // FROM [Название таблицы]
    // WHERE [Список условий]
    // ORDER BY [Список условий, по которым нужно осуществить сортировку]
    // Входные массивы имеют вид:
    //
    // select – список выбираемых столбцов
    // [
    //    'Столбец 1',
    //    'Столбец 2',
    //    ... ,
    //    'Столбец N',
    // ]
    // where – список условий выборки
    // [
    //   [
    //     'Логическая операция условия: AND или OR',
    //     'Условие: < , > , = , >= , <= , LIKE',
    //     'Название столбца',
    //     Значение, с которым требуется сравнить
    //   ],
    //   [
    //     Следующее условие
    //   ]
    // ]
    // order – список столбцов для сортировки
    // [
    //    'Столбец 1',
    //    'Столбец 2',
    //    ... ,
    //    'Столбец N',
    // ]
    public function select($select = [], $where = [], $order = [])
    {
        // Массив для хранения переменных, которые будут подставлены в запрос.
        $varList = [];
        // Инициализация переменной для запроса.
        $query = 'SELECT ';
        // Если список переменных не задан.
        if (empty($select)) {
            // Вместо переменных устанавливает *, что означает возвращение всех столбцов таблицы.
            $query .= '* ';
        } else {
            // Иначе, с помощью функции implode список столбцов из входного параметра select
            // преобразует в строку таким образом, что все столбцы становятся разделены запятой.
            $query .= implode(', ', $this->addQuotes($select)) . ' ';
        }
        // В строку запроса добавляется слово FROM и имя таблицы из свойства tableName
        $query .= 'FROM `' . $this->tableName . '` ';

        // Если массив с условиями заполнен, запрос дополняется условием.
        if (!empty($where)) {
            // Добавляется начальное условие, которое выполняется всегда 1=1 для инициализации запроса.
            $query .= ' WHERE 1=1 ';
            // Перебираются все условия из массива where
            foreach ($where as $condition) {
                // Строка запроса дополняется всеми условиями.
                $query .= $condition[0] . ' (`' . $condition[2] . '` ' . $condition[1] . ' ?) ';
                // В список значений добавляется значение для условия
                $varList[] = $condition[3];
            }
        }
        // Если не пустой массив order.
        if (!empty($order)) {
            // Запрос дополняется списком полей для сортировки.
            $query .= ' ORDER BY ' . implode(', ', $this->addQuotes($order));
        }
        // Выполняется запрос и результат возвращается наружу.
        return App::$db->query($query, $varList);
    }

    // Метод удаляет записи из базы данных.
    // DELETE FROM [Название таблицы]
    // WHERE [Список условий]
    // Входные массивы имеют вид:
    //
    // where – список условий выборки
    // [
    //   [
    //     'Логическая операция условия: AND или OR',
    //     'Условие: < , > , = , >= , <= , LIKE',
    //     'Название столбца',
    //     Значение, с которым требуется сравнить
    //   ],
    //   [
    //     Следующее условие
    //   ]
    // ]
    public function delete($where = [])
    {
        // Массив для хранения переменных, которые будут подставлены в запрос.
        $varList = [];
        // Инициализация переменной для запроса.
        $query = 'DELETE FROM `' . $this->tableName . '` ';
        // Если массив с условиями заполнен, запрос дополняется условием.
        if (!empty($where)) {
            // Добавляется начальное условие, которое выполняется всегда 1=1 для инициализации запроса.
            $query .= ' WHERE 1=1 ';
            // Перебираются все условия из массива where
            foreach ($where as $condition) {
                // Строка запроса дополняется всеми условиями.
                $query .= $condition[0] . ' (`' . $condition[2] . '` ' . $condition[1] . ' ?) ';
                // В список значений добавляется значение для условия.
                $varList[] = $condition[3];
            }
        }
        // Выполняется запрос, и результат возвращается наружу.
        return App::$db->query($query, $varList);
    }
    // Метод вставляет в таблицу новые записи.
    // INSERT INTO [Название таблицы]
    // ([Столбец 1],[Столбец 2]...[Столбец N])
    // VALUES ([value-1],[value-2],[value-3],[value-4],[value-5])
    // Входные массивы имеют вид:
    //
    // varList – список выбираемых столбцов
    // [
    //    'Столбец 1' => Значение 1,
    //    'Столбец 2' => Значение 2,
    //    ... ,
    //    'Столбец N' => Значение N,
    // ]
    public function insert($varList = [])
    {
        // Инициализация переменной для запроса.
        $query = 'INSERT INTO `' . $this->tableName . '` (';
        // С помощью implode собирается строка из названий столбцов.
        // Функция array_keys cоздает массив из названия элементов входного массива.
        $query .= implode(', ', $this->addQuotes(array_keys($varList))) . ') VALUES (';
        // С помощью implode собирается строка из знаков '?'.
        // Функция array_fill cоздает массив нужного размера и заполняет его элементами, содержащими строку.
        // В данном случае массив заполняется знаком '?'.
        $query .= implode(', ', array_fill(0, sizeof($varList), '?')) . ')';
        // Выполняется запрос и результат возвращается наружу.
        return App::$db->query($query, array_values($varList));
    }

    // Метод выполняет обновление записей по условию.
    // UPDATE [Название таблицы]
    // SET [Столбец 1]=[Значение 1],[Столбец 2]=[Значение 2], ... [Столбец N]=[Значение N]
    // WHERE [Список условий]
    // Входные массивы имеют вид:
    //
    // varList – список выбираемых столбцов
    // [
    //    'Столбец 1' => Значение 1,
    //    'Столбец 2' => Значение 2,
    //    ... ,
    //    'Столбец N' => Значение N,
    // ]
    // where – список условий выборки
    // [
    //   [
    //     'Логическая операция условия: AND или OR',
    //     'Условие: < , > , = , >= , <= , LIKE',
    //     'Название столбца',
    //     Значение, с которым требуется сравнить
    //   ],
    //   [
    //     Следующее условие
    //   ]
    // ]
    public function update($varList = [], $where = [])
    {
        // Инициализация переменной для запроса.
        $query = 'UPDATE `' . $this->tableName . '` SET ';
        // С помощью implode собирается строка из названий столбцов.
        // Функция array_keys cоздает массив из названия элементов входного массива.
        $query .= implode('=?, ', $this->addQuotes(array_keys($varList))) . '=? ';
        // В переменную outVarList передается список значений на обновление.
        $outVarList = array_values($varList);
        // Если массив с условиями заполнен, запрос дополняется условием.
        if (!empty($where)) {
            // Добавляется начальное условие, которое выполняется всегда 1=1 для инициализации запроса.
            $query .= ' WHERE 1=1 ';
            // Перебираются все условия из массива where
            foreach ($where as $condition) {
                // Строка запроса дополняется всеми условиями.
                $query .= $condition[0] . ' (`' . $condition[2] . '` ' . $condition[1] . ' ?) ';
                // В список значений добавляется значение для условия
                $outVarList[] = $condition[3];
            }
        }
        // Выполняется запрос, и результат возвращается наружу.
        return App::$db->query($query, array_values($outVarList));
    }
}
?>